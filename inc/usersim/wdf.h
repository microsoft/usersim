// Copyright (c) Microsoft Corporation
// SPDX-License-Identifier: MIT
//
// This file contains user-mode definitions for Wdf* APIs
// implemented in usersim.dll, and can be used by unit tests.
#pragma once
#include "usersim/common.h"
#include "usersim/io.h"  // For IRP
#include "usersim/rtl.h" // For UNICODE_STRING

CXPLAT_EXTERN_C_BEGIN

typedef HANDLE WDFDEVICE;
typedef HANDLE WDFDRIVER;
typedef HANDLE WDFQUEUE;
typedef HANDLE WDFREQUEST;

typedef struct _WDF_OBJECT_ATTRIBUTES
{
    int SynchronizationScope;
} WDF_OBJECT_ATTRIBUTES, *PWDF_OBJECT_ATTRIBUTES;
typedef struct _WDFDEVICE_INIT WDFDEVICE_INIT, *PWDFDEVICE_INIT;

#define WDF_NO_OBJECT_ATTRIBUTES 0
#define WDF_NO_HANDLE 0

typedef NTSTATUS(DRIVER_INITIALIZE)(_In_ PDRIVER_OBJECT driver_object, _In_ PUNICODE_STRING registry_path);

typedef struct _WDFDEVICE_INIT WDFDEVICE_INIT, *PWDFDEVICE_INIT;

typedef NTSTATUS(EVT_WDF_DRIVER_DEVICE_ADD)(_In_ WDFDRIVER driver, _Inout_ PWDFDEVICE_INIT device_init);
typedef EVT_WDF_DRIVER_DEVICE_ADD* PFN_WDF_DRIVER_DEVICE_ADD;

typedef void(EVT_WDF_DRIVER_UNLOAD)(_In_ WDFDRIVER driver);
typedef EVT_WDF_DRIVER_UNLOAD* PFN_WDF_DRIVER_UNLOAD;

typedef struct _WDF_DRIVER_CONFIG
{
    ULONG Size;
    PFN_WDF_DRIVER_DEVICE_ADD EvtDriverDeviceAdd;
    PFN_WDF_DRIVER_UNLOAD EvtDriverUnload;
    ULONG DriverInitFlags;
    ULONG DriverPoolTag;
} WDF_DRIVER_CONFIG, *PWDF_DRIVER_CONFIG;

struct _DRIVER_OBJECT
{
    WDF_DRIVER_CONFIG config;
    PDEVICE_OBJECT device;
    PWDFDEVICE_INIT device_init;
};

#define WDF_DRIVER_GLOBALS_NAME_LEN (32)

typedef struct _WDF_DRIVER_GLOBALS
{
    // backpointer to the handle for this driver
    WDFDRIVER Driver;

    // Flags indicated by the driver during create
    ULONG DriverFlags;

    // Tag generated by WDF for the driver.  Tag used by allocations made on
    // behalf of the driver by WDF.
    ULONG DriverTag;

    CHAR DriverName[WDF_DRIVER_GLOBALS_NAME_LEN];

    // If TRUE, the stub code will capture DriverObject->DriverUnload and insert
    // itself first in the unload chain.  If FALSE, DriverUnload is left alone
    // (but WDF will not be notified of unload and there will be no auto cleanup).
    BOOLEAN DisplaceDriverUnload;

} WDF_DRIVER_GLOBALS, *PWDF_DRIVER_GLOBALS;

typedef VOID (*WDFFUNC)(VOID);

USERSIM_API
void
WDF_DRIVER_CONFIG_INIT(_Out_ PWDF_DRIVER_CONFIG config, _In_opt_ PFN_WDF_DRIVER_DEVICE_ADD evt_driver_device_add);

typedef NTSTATUS(WdfDriverCreate_t)(
    _In_ WDF_DRIVER_GLOBALS* driver_globals,
    _In_ PDRIVER_OBJECT driver_object,
    _In_ PCUNICODE_STRING registry_path,
    _In_opt_ PWDF_OBJECT_ATTRIBUTES driver_attributes,
    _In_ PWDF_DRIVER_CONFIG driver_config,
    _Out_opt_ WDFDRIVER* driver);

typedef NTSTATUS(WdfDeviceCreate_t)(
    _In_ WDF_DRIVER_GLOBALS* driver_globals,
    _Inout_ PWDFDEVICE_INIT* device_init,
    _In_opt_ PWDF_OBJECT_ATTRIBUTES device_attributes,
    _Out_ WDFDEVICE* device);

typedef _IRQL_requires_max_(DISPATCH_LEVEL)
    VOID(WdfDeviceInitFree_t)(_In_ PWDF_DRIVER_GLOBALS driver_globals, _In_ PWDFDEVICE_INIT device_init);

typedef _Must_inspect_result_ _IRQL_requires_max_(PASSIVE_LEVEL) PWDFDEVICE_INIT(WdfControlDeviceInitAllocate_t)(
    _In_ PWDF_DRIVER_GLOBALS driver_globals, _In_ WDFDRIVER driver, _In_ CONST UNICODE_STRING* sddl_string);

typedef _IRQL_requires_max_(DISPATCH_LEVEL) VOID(WdfDeviceInitSetDeviceType_t)(
    _In_ PWDF_DRIVER_GLOBALS driver_globals, _In_ PWDFDEVICE_INIT device_init, DEVICE_TYPE device_type);

#define FILE_AUTOGENERATED_DEVICE_NAME 0x00000080
#define FILE_DEVICE_SECURE_OPEN 0x00000100

typedef _IRQL_requires_max_(DISPATCH_LEVEL) VOID(WdfDeviceInitSetCharacteristics_t)(
    _In_ PWDF_DRIVER_GLOBALS driver_globals,
    _In_ PWDFDEVICE_INIT device_init,
    ULONG device_characteristics,
    BOOLEAN or_in_values);

typedef _Must_inspect_result_ _IRQL_requires_max_(PASSIVE_LEVEL) NTSTATUS(WdfDeviceInitAssignName_t)(
    _In_ PWDF_DRIVER_GLOBALS driver_globals, _In_ PWDFDEVICE_INIT device_init, _In_opt_ PCUNICODE_STRING device_name);

typedef struct _WDF_FILEOBJECT_CONFIG
{
    int unused;
} WDF_FILEOBJECT_CONFIG, *PWDF_FILEOBJECT_CONFIG;

typedef _IRQL_requires_max_(DISPATCH_LEVEL) VOID(WdfDeviceInitSetFileObjectConfig_t)(
    _In_ PWDF_DRIVER_GLOBALS driver_globals,
    _In_ PWDFDEVICE_INIT device_init,
    _In_ PWDF_FILEOBJECT_CONFIG file_object_config,
    _In_opt_ PWDF_OBJECT_ATTRIBUTES file_object_attributes);

typedef NTSTATUS(FN_WDFDEVICE_WDM_IRP_PREPROCESS)(_In_ WDFDEVICE device, _Inout_ IRP* irp);
typedef FN_WDFDEVICE_WDM_IRP_PREPROCESS* PFN_WDFDEVICE_WDM_IRP_PREPROCESS;

#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a

typedef _Must_inspect_result_ _IRQL_requires_max_(DISPATCH_LEVEL)
    NTSTATUS(WdfDeviceInitAssignWdmIrpPreprocessCallback_t)(
        _In_ PWDF_DRIVER_GLOBALS driver_globals,
        _In_ PWDFDEVICE_INIT device_init,
        _In_ PFN_WDFDEVICE_WDM_IRP_PREPROCESS evt_device_wdm_irp_preprocess,
        UCHAR major_function,
        _When_(num_minor_functions > 0, _In_reads_bytes_(num_minor_functions))
            _When_(num_minor_functions == 0, _In_opt_) PUCHAR minor_functions,
        ULONG num_minor_functions);

typedef _Must_inspect_result_ _IRQL_requires_max_(PASSIVE_LEVEL) NTSTATUS(WdfDeviceCreateSymbolicLink_t)(
    _In_ PWDF_DRIVER_GLOBALS driver_globals, _In_ WDFDEVICE device, _In_ PCUNICODE_STRING symbolic_link_name);

typedef int WDF_IO_QUEUE_DISPATCH_TYPE;
typedef int WDF_TRI_STATE;
typedef void* PFN_WDF_IO_QUEUE_IO_DEFAULT;
typedef void* PFN_WDF_IO_QUEUE_IO_READ;
typedef void* PFN_WDF_IO_QUEUE_IO_WRITE;
typedef void (*PFN_WDF_IO_QUEUE_IO_DEVICE_CONTROL)(
    _In_ WDFQUEUE queue,
    _In_ WDFREQUEST request,
    size_t output_buffer_length,
    size_t input_buffer_length,
    unsigned long io_control_code);

typedef void* PFN_WDF_IO_QUEUE_IO_INTERNAL_DEVICE_CONTROL;
typedef void* PFN_WDF_IO_QUEUE_IO_STOP;
typedef void* PFN_WDF_IO_QUEUE_IO_RESUME;
typedef void* PFN_WDF_IO_QUEUE_IO_CANCELED_ON_QUEUE;

typedef struct _WDF_IO_QUEUE_CONFIG
{
    ULONG Size;
    WDF_IO_QUEUE_DISPATCH_TYPE DispatchType;
    WDF_TRI_STATE PowerManaged;
    BOOLEAN AllowZeroLengthRequests;
    BOOLEAN DefaultQueue;
    PFN_WDF_IO_QUEUE_IO_DEFAULT EvtIoDefault;
    PFN_WDF_IO_QUEUE_IO_READ EvtIoRead;
    PFN_WDF_IO_QUEUE_IO_WRITE EvtIoWrite;
    PFN_WDF_IO_QUEUE_IO_DEVICE_CONTROL EvtIoDeviceControl;
    PFN_WDF_IO_QUEUE_IO_INTERNAL_DEVICE_CONTROL EvtIoInternalDeviceControl;
    PFN_WDF_IO_QUEUE_IO_STOP EvtIoStop;
    PFN_WDF_IO_QUEUE_IO_RESUME EvtIoResume;
    PFN_WDF_IO_QUEUE_IO_CANCELED_ON_QUEUE EvtIoCanceledOnQueue;
    ULONG NumberOfPresentedRequests;
    WDFDRIVER Driver;
} WDF_IO_QUEUE_CONFIG, *PWDF_IO_QUEUE_CONFIG;

typedef _Must_inspect_result_ _IRQL_requires_max_(DISPATCH_LEVEL) NTSTATUS(WdfIoQueueCreate_t)(
    _In_ PWDF_DRIVER_GLOBALS driver_globals,
    _In_ WDFDEVICE device,
    _In_ PWDF_IO_QUEUE_CONFIG config,
    _In_opt_ PWDF_OBJECT_ATTRIBUTES queue_attributes,
    _Out_opt_ WDFQUEUE* queue);

typedef _IRQL_requires_max_(DISPATCH_LEVEL) WDFDEVICE(WdfIoQueueGetDevice_t)(_In_ WDFQUEUE queue);

typedef _IRQL_requires_max_(DISPATCH_LEVEL)
    VOID(WdfControlFinishInitializing_t)(_In_ PWDF_DRIVER_GLOBALS driver_globals, _In_ WDFDEVICE device);

typedef _IRQL_requires_max_(DISPATCH_LEVEL)
    PDEVICE_OBJECT(WdfDeviceWdmGetDeviceObject_t)(_In_ PWDF_DRIVER_GLOBALS driver_globals, _In_ WDFDEVICE device);

typedef HANDLE WDFOBJECT;

typedef _IRQL_requires_max_(DISPATCH_LEVEL)
    VOID(WdfObjectDelete_t)(_In_ PWDF_DRIVER_GLOBALS driver_globals, _In_ WDFOBJECT object);

typedef _IRQL_requires_max_(DISPATCH_LEVEL) VOID (WdfRequestCompleteWithInformation_t)(
    _In_ PWDF_DRIVER_GLOBALS driver_globals, _In_ WDFREQUEST request, _In_ NTSTATUS status, _In_ ULONG_PTR information);

typedef _Must_inspect_result_ _IRQL_requires_max_(DISPATCH_LEVEL) NTSTATUS(WdfRequestRetrieveInputBuffer_t)(
    _In_ PWDF_DRIVER_GLOBALS driver_globals,
    _In_ WDFREQUEST request,
    _In_ size_t minimum_required_length,
    _Outptr_result_bytebuffer_(*length) PVOID* buffer,
    _Out_opt_ size_t* length);

typedef _Must_inspect_result_ _IRQL_requires_max_(DISPATCH_LEVEL) NTSTATUS(WdfRequestRetrieveOutputBuffer_t)(
    _In_ PWDF_DRIVER_GLOBALS driver_globals,
    _In_ WDFREQUEST request,
    _In_ size_t minimum_required_size,
    _Outptr_result_bytebuffer_(*length) PVOID* buffer,
    _Out_opt_ size_t* length);

typedef enum _WDFFUNCENUM
{
    WdfControlDeviceInitAllocateTableIndex = 25,
    WdfControlFinishInitializingTableIndex = 27,
    WdfDeviceWdmGetDeviceObjectTableIndex = 31,
    WdfDeviceInitFreeTableIndex = 54,
    WdfDeviceInitSetDeviceTypeTableIndex = 66,
    WdfDeviceInitAssignNameTableIndex = 67,
    WdfDeviceInitSetCharacteristicsTableIndex = 70,
    WdfDeviceInitSetFileObjectConfigTableIndex = 71,
    WdfDeviceInitAssignWdmIrpPreprocessCallbackTableIndex = 73,
    WdfDeviceCreateTableIndex = 75,
    WdfDeviceCreateSymbolicLinkTableIndex = 80,
    WdfDriverCreateTableIndex = 116,
    WdfIoQueueCreateTableIndex = 152,
    WdfIoQueueGetDeviceTableIndex = 157,
    WdfObjectDeleteTableIndex = 208,
    WdfRequestCompleteWithInformationTableIndex = 265,
    WdfRequestRetrieveInputBufferTableIndex = 269,
    WdfRequestRetrieveOutputBufferTableIndex = 270,
    WdfFunctionTableNumEntries = 444,
} WDFFUNCENUM;

void
usersim_initialize_wdf();

USERSIM_API
HANDLE usersim_get_device_handle(HMODULE module);

typedef HANDLE (*usersim_dll_get_device_handle_t)();

USERSIM_API
BOOL
usersim_device_io_control(
    HANDLE device_handle,
    DWORD io_control_code,
    _In_reads_opt_(in_buffer_size) void* in_buffer,
    DWORD in_buffer_size,
    _Out_writes_to_opt_(out_buffer_size, *bytes_returned) void* out_buffer,
    DWORD out_buffer_size,
    _Out_opt_ DWORD* bytes_returned,
    _Inout_opt_ OVERLAPPED* overlapped);

CXPLAT_EXTERN_C_END
