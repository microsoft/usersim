// Copyright (c) Microsoft Corporation
// SPDX-License-Identifier: MIT
//
// This file contains user-mode definitions for Wdf* APIs
// implemented in usersim.dll, and can be used by unit tests.
#pragma once
#include "usersim/common.h"
#include "usersim/rtl.h" // For UNICODE_STRING

#if defined(__cplusplus)
extern "C"
{
#endif

    typedef HANDLE WDFDEVICE;
    typedef HANDLE WDFDRIVER;

    typedef struct _WDF_OBJECT_ATTRIBUTES WDF_OBJECT_ATTRIBUTES, *PWDF_OBJECT_ATTRIBUTES;
    typedef struct _WDFDEVICE_INIT WDFDEVICE_INIT, *PWDFDEVICE_INIT;

#define WDF_NO_OBJECT_ATTRIBUTES 0
#define WDF_NO_HANDLE 0

    typedef struct _driver_object DRIVER_OBJECT, *PDRIVER_OBJECT;

    typedef NTSTATUS(DRIVER_INITIALIZE)(_In_ PDRIVER_OBJECT driver_object, _In_ PUNICODE_STRING registry_path);

    typedef struct _WDFDEVICE_INIT WDFDEVICE_INIT, *PWDFDEVICE_INIT;

    typedef NTSTATUS(EVT_WDF_DRIVER_DEVICE_ADD)(_In_ WDFDRIVER driver, _Inout_ PWDFDEVICE_INIT device_init);
    typedef EVT_WDF_DRIVER_DEVICE_ADD* PFN_WDF_DRIVER_DEVICE_ADD;

    typedef void(EVT_WDF_DRIVER_UNLOAD)(_In_ WDFDRIVER driver);
    typedef EVT_WDF_DRIVER_UNLOAD* PFN_WDF_DRIVER_UNLOAD;

    typedef struct _WDF_DRIVER_CONFIG
    {
        ULONG Size;
        PFN_WDF_DRIVER_DEVICE_ADD EvtDriverDeviceAdd;
        PFN_WDF_DRIVER_UNLOAD EvtDriverUnload;
        ULONG DriverInitFlags;
        ULONG DriverPoolTag;
    } WDF_DRIVER_CONFIG, *PWDF_DRIVER_CONFIG;

    struct _driver_object
    {
        WDF_DRIVER_CONFIG config;
    };

#define WDF_DRIVER_GLOBALS_NAME_LEN (32)

    typedef struct _WDF_DRIVER_GLOBALS
    {
        // backpointer to the handle for this driver
        WDFDRIVER Driver;

        // Flags indicated by the driver during create
        ULONG DriverFlags;

        // Tag generated by WDF for the driver.  Tag used by allocations made on
        // behalf of the driver by WDF.
        ULONG DriverTag;

        CHAR DriverName[WDF_DRIVER_GLOBALS_NAME_LEN];

        // If TRUE, the stub code will capture DriverObject->DriverUnload and insert
        // itself first in the unload chain.  If FALSE, DriverUnload is left alone
        // (but WDF will not be notified of unload and there will be no auto cleanup).
        BOOLEAN DisplaceDriverUnload;

    } WDF_DRIVER_GLOBALS, *PWDF_DRIVER_GLOBALS;

    typedef VOID (*WDFFUNC)(VOID);

    USERSIM_API
    void
    WDF_DRIVER_CONFIG_INIT(_Out_ PWDF_DRIVER_CONFIG config, _In_opt_ PFN_WDF_DRIVER_DEVICE_ADD evt_driver_device_add);

    typedef enum _WDFFUNCENUM
    {
        WdfControlDeviceInitAllocateTableIndex = 25,
        WdfDeviceInitSetDeviceTypeTableIndex = 66,
        WdfDeviceInitAssignNameTableIndex = 67,
        WdfDeviceInitSetCharacteristicsTableIndex = 70,
        WdfDeviceInitSetFileObjectConfigTableIndex = 71,
        WdfDeviceInitAssignWdmIrpPreprocessCallbackTableIndex = 73,
        WdfDeviceCreateTableIndex = 75,
        WdfDeviceCreateSymbolicLinkTableIndex = 80,
        WdfDriverCreateTableIndex = 116,
        WdfIoQueueCreateTableIndex = 152,
        WdfObjectDeleteTableIndex = 208,
        WdfFunctionTableNumEntries = 444,
    } WDFFUNCENUM;

    void
    usersim_initialize_wdf();

#if defined(__cplusplus)
}
#endif